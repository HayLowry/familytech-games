[{"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/_app.js":"1","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/_document.js":"2","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/health.js":"3","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/questiongenerator.js":"4","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/socket.js":"5","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/crossword.js":"6","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/example.js":"7","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/family_photo_shoot.js":"8","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/geneopardy.js":"9","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/index.js":"10","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/login.js":"11","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/matching_game.js":"12","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/wheel_family_fortune.js":"13","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/who's_your_daddy.js":"14","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/word_scramble.js":"15","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/word_search.js":"16","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/board.js":"17","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/clue.js":"18","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/clue_list.js":"19","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/square.js":"20","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game.js":"21","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game_card_coming_soon.js":"22","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game_card_pitch.js":"23","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/login_button.js":"24","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/grid.js":"25","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/match_board.js":"26","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/roomSetup.js":"27","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/menu/contact.js":"28","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/menu/menu_dialog.js":"29","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/person.js":"30","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/person_image.js":"31","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/victory_modal.js":"32","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/word_scramble/scramble_solve.js":"33","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/lib/theme.js":"34","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/lib/utils.js":"35"},{"size":1420,"mtime":1689793536000,"results":"36","hashOfConfig":"37"},{"size":1240,"mtime":1689793536000,"results":"38","hashOfConfig":"37"},{"size":86,"mtime":1689793536000,"results":"39","hashOfConfig":"37"},{"size":6138,"mtime":1689793536000,"results":"40","hashOfConfig":"37"},{"size":1096,"mtime":1689793536000,"results":"41","hashOfConfig":"37"},{"size":303,"mtime":1689793536000,"results":"42","hashOfConfig":"37"},{"size":1699,"mtime":1689793536000,"results":"43","hashOfConfig":"37"},{"size":120,"mtime":1689793536000,"results":"44","hashOfConfig":"37"},{"size":100,"mtime":1689793536000,"results":"45","hashOfConfig":"37"},{"size":2155,"mtime":1689793536000,"results":"46","hashOfConfig":"37"},{"size":537,"mtime":1689793536000,"results":"47","hashOfConfig":"37"},{"size":2842,"mtime":1689793536000,"results":"48","hashOfConfig":"37"},{"size":131,"mtime":1689793536000,"results":"49","hashOfConfig":"37"},{"size":117,"mtime":1689793536000,"results":"50","hashOfConfig":"37"},{"size":6658,"mtime":1689793536000,"results":"51","hashOfConfig":"37"},{"size":11702,"mtime":1689793536000,"results":"52","hashOfConfig":"37"},{"size":25872,"mtime":1696272789239,"results":"53","hashOfConfig":"37"},{"size":1601,"mtime":1689793536000,"results":"54","hashOfConfig":"37"},{"size":1989,"mtime":1689793536000,"results":"55","hashOfConfig":"37"},{"size":1541,"mtime":1689793536000,"results":"56","hashOfConfig":"37"},{"size":3157,"mtime":1689793536000,"results":"57","hashOfConfig":"37"},{"size":552,"mtime":1689793536000,"results":"58","hashOfConfig":"37"},{"size":316,"mtime":1689793536000,"results":"59","hashOfConfig":"37"},{"size":839,"mtime":1689793536000,"results":"60","hashOfConfig":"37"},{"size":3888,"mtime":1689793536000,"results":"61","hashOfConfig":"37"},{"size":0,"mtime":1689793536000,"results":"62","hashOfConfig":"37"},{"size":3420,"mtime":1689793536000,"results":"63","hashOfConfig":"37"},{"size":3841,"mtime":1689793536000,"results":"64","hashOfConfig":"37"},{"size":1539,"mtime":1689793536000,"results":"65","hashOfConfig":"37"},{"size":1358,"mtime":1689793536000,"results":"66","hashOfConfig":"37"},{"size":2244,"mtime":1689793536000,"results":"67","hashOfConfig":"37"},{"size":1661,"mtime":1689793536000,"results":"68","hashOfConfig":"37"},{"size":2927,"mtime":1689793536000,"results":"69","hashOfConfig":"37"},{"size":577,"mtime":1689793536000,"results":"70","hashOfConfig":"37"},{"size":835,"mtime":1689793536000,"results":"71","hashOfConfig":"37"},{"filePath":"72","messages":"73","suppressedMessages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"xddi4f",{"filePath":"75","messages":"76","suppressedMessages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78"},{"filePath":"79","messages":"80","suppressedMessages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","suppressedMessages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","suppressedMessages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","suppressedMessages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"91","messages":"92","suppressedMessages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94"},{"filePath":"95","messages":"96","suppressedMessages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"98","messages":"99","suppressedMessages":"100","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"101","messages":"102","suppressedMessages":"103","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"104","messages":"105","suppressedMessages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107"},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"114","messages":"115","suppressedMessages":"116","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"117","messages":"118","suppressedMessages":"119","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"120","messages":"121","suppressedMessages":"122","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123"},{"filePath":"124","messages":"125","suppressedMessages":"126","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"127"},{"filePath":"128","messages":"129","suppressedMessages":"130","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"131","messages":"132","suppressedMessages":"133","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"134"},{"filePath":"135","messages":"136","suppressedMessages":"137","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"138","messages":"139","suppressedMessages":"140","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141"},{"filePath":"142","messages":"143","suppressedMessages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"145","messages":"146","suppressedMessages":"147","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"148","messages":"149","suppressedMessages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"151","messages":"152","suppressedMessages":"153","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"154"},{"filePath":"155","messages":"156","suppressedMessages":"157","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"158","messages":"159","suppressedMessages":"160","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"161","messages":"162","suppressedMessages":"163","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"164","messages":"165","suppressedMessages":"166","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","suppressedMessages":"169","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"170","messages":"171","suppressedMessages":"172","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"173","messages":"174","suppressedMessages":"175","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"176","messages":"177","suppressedMessages":"178","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"179","messages":"180","suppressedMessages":"181","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"182","messages":"183","suppressedMessages":"184","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/_app.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/_document.js",["185"],[],"// pages/_document.js\r\n\r\nimport Document, { Html, Head, Main, NextScript } from \"next/document\";\r\n\r\nclass MyDocument extends Document {\r\n  render() {\r\n    return (\r\n      <Html>\r\n        <Head>\r\n          <title>FamilyTech Games</title>\r\n\r\n          <meta name=\"description\" content=\"Free, fun family history games\" />\r\n          <meta name=\"keywords\"    content=\"Family, Family History, Genealogy, Ancestor, Relative, Games\" />\r\n          <meta name=\"theme-color\" content=\"#2a3492\" /> {/* var(--blue) in globals.css */}\r\n\r\n          <link rel=\"manifest\" href=\"/manifest.json\" />\r\n          \r\n          <link rel=\"icon\"     href=\"/favicon.ico\" />\r\n          <link rel=\"apple-touch-icon\" href=\"/icon192x192.png\"></link>\r\n\r\n          <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\r\n          <link\r\n            rel=\"preconnect\"\r\n            href=\"https://fonts.gstatic.com\"\r\n            crossOrigin=\"true\"\r\n          />\r\n          <link\r\n            href=\"https://fonts.googleapis.com/css2?family=Electrolize&display=swap\"\r\n            rel=\"stylesheet\"\r\n          />\r\n        </Head>\r\n\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MyDocument;\r\n","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/health.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/questiongenerator.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/api/socket.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/crossword.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/example.js",["186"],[],"import { useEffect } from 'react'\r\nimport axios from 'axios'\r\nimport { useUser } from '@/contexts/UserContext';\r\nimport styles from '@/styles/Person.module.css';\r\n\r\nexport default function Example() {\r\n  const { userFSData } = useUser();\r\n  //console.log(\"data out of context \" + userFSData);\r\n\r\n  useEffect(() => {\r\n    if (userFSData) {\r\n      //console.log(\"data in if statement \" + Array.from(userFSData.values()).length);\r\n      const fsDataObj = Object.fromEntries(userFSData);\r\n      let ascendancyNums = Array.from(userFSData.values()).map((person) => person.a_num);\r\n      getQuestions(fsDataObj, ascendancyNums);\r\n    }\r\n  }, [])\r\n\r\n  return (\r\n    <div>\r\n      <h1>Example</h1>\r\n      {userFSData && Array.from(userFSData.values()).map((person, key) => {\r\n        // return (\r\n        //   <div key={key}>\r\n        //     {value.a_num}\r\n        //   </div>\r\n        // )\r\n        return <Person personData={person} key={key} />;\r\n      })}\r\n    </div>\r\n  );\r\n}\r\n\r\n// NOTE: Components should be in separate files to reduce confusion.\r\n// This is for demonstration purposes only.\r\nfunction Person({ personData }) {\r\n  return (\r\n    <div className={styles.container}>\r\n      <h2>{personData.name.full}</h2>\r\n      <h2>{personData.gender}</h2>\r\n      <h2>{personData.lifespan.string}</h2>\r\n      <h2>{personData.birthDate.original}</h2>\r\n      <h2>{personData.birthPlace}</h2>\r\n    </div>\r\n  );\r\n}\r\n\r\nasync function getQuestions(userFSData, ascendancyNums) {\r\n  const url = \"http://localhost:3000/api/questiongenerator\"\r\n  await axios.post(url, {userFSData, ascendancyNums}).then((res) => {\r\n    console.log('res:', res)\r\n  })\r\n  .catch((err) => {\r\n    console.log('err:', err)\r\n  })\r\n}\r\n\r\n\r\n","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/family_photo_shoot.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/geneopardy.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/index.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/login.js",["187"],[],"import LoginButton from '@/components/login_button';\r\nimport styles from '@/styles/login.module.css';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function Login() {\r\n  const { cookieExists } = useAuth();\r\n  const router = useRouter();\r\n\r\n  useEffect(() => {\r\n    if (cookieExists) {\r\n      router.push(\"/\");\r\n    }\r\n  }, [cookieExists])\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <LoginButton />\r\n    </div>\r\n  );\r\n}\r\n","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/matching_game.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/wheel_family_fortune.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/who's_your_daddy.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/word_scramble.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/pages/word_search.js",["188"],[],"import { useEffect, useState, useRef } from \"react\";\r\nimport { Modal } from \"@mui/material\";\r\nimport VictoryModal from \"@/components/victory_modal\";\r\nimport Person from \"@/components/person\";\r\nimport { useUser } from \"@/contexts/UserContext\";\r\nimport styles from \"@/styles/word_search.module.css\"\r\n\r\nfunction WordSearchPage() {\r\n\r\n    //determines whether the win message is shown or hidden.\r\n    const [showWinModal, setShowWinModal] = useState(false);\r\n\r\n    // variable person\r\n    const [currentPerson, setCurrentPerson] = useState(null)\r\n\r\n    //get fsData from our custom hook.\r\n    const { userFSData } = useUser();\r\n    useEffect(() => {}, [userFSData]);\r\n\r\n    //set an array of people comprised of the user's ancestors\r\n    const [peopleArray, setPeopleArray] = useState([]);\r\n    useEffect(() => {\r\n        const numPeopleToDisplay = 10;\r\n\r\n        let people = Array.from(userFSData.values()).map((person) => person);\r\n        setPeopleArray(\r\n          people.sort(() => 0.5 - Math.random()).slice(0, numPeopleToDisplay)\r\n        );\r\n    }, [userFSData]);\r\n\r\n    // BOARD SET-UP (visible board and interactive board)\r\n    function populateBoard() {\r\n        var board = [];\r\n        solutionBank.length = 0;\r\n        placedPeople.length = 0;\r\n    \r\n        // establish an initial board\r\n        for(var i=0; i<rows; i++){\r\n            board.push([new Array(cols)]);\r\n            for(var j=0; j<cols; j++){\r\n                board[i][j] = defVal;\r\n            }\r\n        }\r\n    \r\n        // for as many names as there are in the list, place them on the board\r\n        for(var i=0; i<peopleArray.length; i++){\r\n            var name = peopleArray[i].name.first.toUpperCase()\r\n            placeWord(board, peopleArray[i], name)\r\n        }\r\n    \r\n        // finish board by setting any cells with 0 to a random letter\r\n        for(var i=0; i<rows; i++){\r\n            for(var j=0; j<cols; j++){\r\n                if(board[i][j] == defVal){\r\n                    board[i][j] = alphabet[Math.floor(Math.random() * 26)];\r\n                }\r\n            }\r\n        }\r\n    \r\n        return board\r\n    }\r\n    const [wsboard, setBoard] = useState([])\r\n    useEffect(() => setBoard(populateBoard),[peopleArray])\r\n    const [refBoard, setRefBoard] = useState([])\r\n    useEffect(() => setRefBoard(populateRefBoard),[])\r\n\r\n    // MODAL\r\n    const [showPersonInfo, setShowPersonInfo] = useState(false);    \r\n\r\n    // HOVER\r\n    function handleMouseOver(e,r_idx,c_idx) {\r\n        if(selectionBegun){\r\n            currentLocation = [r_idx,c_idx];\r\n            let diffRow = selectionStart[0] - currentLocation[0];\r\n            let diffCol = selectionStart[1] - currentLocation[1];\r\n            if (diffRow == 0 || diffCol == 0 || Math.abs(diffCol) == Math.abs(diffRow)){\r\n                for(var i=0; i<rows; i++){\r\n                    for(var j=0; j<cols; j++){\r\n                        refBoard[i][j].style.background = \"white\"\r\n                    }\r\n                }\r\n                var directionRow = (1 * (diffRow < 0)) - (1 * (diffRow > 0));\r\n                var directionCol = (1 * (diffCol < 0)) - (1 * (diffCol > 0));\r\n                var endLocation = currentLocation;\r\n                drawLine(selectionStart, endLocation, directionRow, directionCol, refBoard);\r\n            }\r\n        }\r\n        else e.target.style.background = \"lightgray\";\r\n    }\r\n    function handleMouseLeave(e) { e.target.style.background = \"white\" }\r\n\r\n    function nameMouseOver(e,person) {\r\n        e.target.style.background = \"lightgray\"\r\n        setCurrentPerson(person)\r\n    }\r\n\r\n    // SELECTION\r\n    function handleMouseDown(e,r_idx,c_idx) {\r\n        // indicate the beginning of a solution attempt\r\n        selectionBegun = true;\r\n        e.target.style.background = \"orange\";\r\n\r\n        // initiate guess\r\n        selectionStart = [r_idx,c_idx]\r\n        guess.push(selectionStart)\r\n    }\r\n    function handleMouseUp(r_idx,c_idx) {\r\n        // clear the selection highlighting\r\n        for(var i=0; i<rows; i++){\r\n            for(var j=0; j<cols; j++){\r\n                refBoard[i][j].style.background = \"white\"\r\n            }\r\n        }\r\n\r\n        guess.push([r_idx,c_idx]);\r\n        var [found, idx] = checkSolution(guess);\r\n        // if a name is found, highlight the board's cells and the name in the box\r\n        if(found){\r\n            let diffRow = selectionStart[0] - r_idx\r\n            let diffCol = selectionStart[1] - c_idx\r\n            if (diffRow == 0 || diffCol == 0 || Math.abs(diffCol) == Math.abs(diffRow)){\r\n                var directionRow = (1 * (diffRow < 0)) - (1 * (diffRow > 0));\r\n                var directionCol = (1 * (diffCol < 0)) - (1 * (diffCol > 0));\r\n                highlightSolution(selectionStart, directionRow, directionCol, refBoard, nameRefs, idx)\r\n            }\r\n        }\r\n        \r\n        // reset and adjust our guessing related global helper variables\r\n        selectionBegun = false;\r\n        guess.length = 0;\r\n        selectionStart = [];\r\n\r\n        //if we have found all the people, win\r\n        if(guessedList.length == placedPeople.length) setShowWinModal(true)\r\n\r\n    }\r\n    function handleNameClick(){ setShowPersonInfo(true) }\r\n\r\n    // create references for each div that displays a placed name (for the style updater that happens when handling mouseUp)\r\n    const nameRefs = useRef([]);\r\n    nameRefs.current = []\r\n    const addToNameRefs = (e) => {\r\n        nameRefs.current.push(e)\r\n    }\r\n    // create references for each cell of the board to enable the mutation of a cell at any time\r\n    const addToBoardRef = (e,r_idx,c_idx) => {\r\n        refBoard[r_idx][c_idx] = e\r\n    }\r\n\r\n    return ( \r\n        <div>\r\n            <div className={styles.ws_board}>\r\n                {wsboard.map((row,r_idx) => (\r\n                <div className={styles.ws_container} key={r_idx}>\r\n                    {row.map((cell,c_idx) =>\r\n                        <button className={styles.ws_cell}\r\n                        key={c_idx}\r\n                        onMouseDown={(e) => handleMouseDown(e,r_idx,c_idx)}\r\n                        onMouseUp={() => handleMouseUp(r_idx,c_idx)}\r\n                        onMouseEnter={(e) => handleMouseOver(e,r_idx,c_idx)}\r\n                        onMouseLeave={handleMouseLeave}\r\n                        ref={(e) => addToBoardRef(e,r_idx,c_idx)}>\r\n                            {cell}\r\n                        </button>)}\r\n                </div>))}\r\n            </div>\r\n\r\n            <div className={styles.ws_container}>\r\n                <div className={styles.ws_names_container}>\r\n                    {placedPeople.map((person,idx) => \r\n                    <button className={styles.ws_name}\r\n                    key={idx} \r\n                    ref={addToNameRefs}\r\n                    onClick={handleNameClick}\r\n                    onMouseEnter={(e) => nameMouseOver(e,person)}\r\n                    onMouseLeave={handleMouseLeave}>\r\n                        {person.name.first.toUpperCase()}\r\n                    </button>)}\r\n                </div>\r\n            </div>\r\n\r\n            <Modal open={showPersonInfo} onClose={() => setShowPersonInfo(false)}>\r\n                <Person personData={currentPerson}/>\r\n            </Modal>\r\n\r\n            <VictoryModal\r\n            open={showWinModal}\r\n            onClose={() => setShowWinModal(false)}\r\n            message=\"You solved the Word Search!\"\r\n            />\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\n// set up a reference board to store the cells of the board as mutable DOM elements\r\nfunction populateRefBoard(){\r\n    var refBoard = []\r\n\r\n    //establish refBoard\r\n    for(var i=0; i<rows; i++){\r\n        refBoard.push([new Array(cols)]);\r\n    }\r\n\r\n    return refBoard\r\n}\r\n\r\n// PLACEMENT\r\nfunction placeWord(board, person, name){\r\n    var maxAttempts = 10\r\n\r\n    for(var i=0; i<maxAttempts; i++){\r\n\r\n        // set start positions ([0]=row, [1]=col)\r\n        var start = [Math.floor(Math.random() * rows),Math.floor(Math.random() * cols)]\r\n\r\n        // get a direction\r\n        var directionIndex = Math.floor(Math.random() * 8)\r\n        var direction = allDirections[directionIndex]\r\n\r\n        // find the potential end positions ([0]=row, [1]=col)\r\n        var end = [start[0] + (direction[0] * (name.length-1)), start[1] + (direction[1] * (name.length-1))]\r\n\r\n        // check if word will fit on board, keep trying to place if out of bounds\r\n        if(end[0]<0 || end[0]>rows-1 || end[1]<0 || end[1]>cols-1) continue\r\n        else{\r\n          // from the starting position, place each letter of the name in the given direction\r\n          permitAndPlace(board, start, end, direction, person, name)\r\n          break\r\n        }\r\n    }\r\n\r\n    return board;\r\n}\r\nfunction permitAndPlace(board, start, end, direction, person, name){\r\n\r\n    for(var i=0; i<name.length; i++){\r\n        let cell = board[start[0]+(direction[0]*i)][start[1]+(direction[1]*i)]\r\n        let letter = name[i]\r\n        if(cell != letter && cell != defVal) return false; // disallows a word's placement\r\n    }\r\n\r\n    // place the word\r\n    for(var i=0; i<name.length; i++) board[start[0]+(direction[0]*i)][start[1]+(direction[1]*i)] = name[i];\r\n\r\n    // store start and end positions as a solution in the solution bank\r\n    var solution = [start,end]\r\n    solutionBank.push(solution)\r\n\r\n    // keep record that the name was officially placed\r\n    placedPeople.push(person)\r\n\r\n    return true\r\n}\r\n\r\n// SOLUTION HELPERS\r\nfunction checkSolution(proposedSolution){\r\n\r\n    let proposedSolutionString = JSON.stringify(proposedSolution)\r\n\r\n    if( !guessedList.includes(proposedSolutionString) && placedPeople.includes(proposedSolutionString)) guessedList.push(proposedSolutionString)\r\n\r\n    for(var i=0; i<solutionBank.length; i++){\r\n        let solutionBank_i = JSON.stringify(solutionBank[i])\r\n        var found = (proposedSolutionString == solutionBank_i)\r\n        if(found) break\r\n    }\r\n\r\n    return [found, i]\r\n}\r\n\r\nfunction drawLine(selectionStart, endLocation, directionRow, directionCol, refBoard){\r\n    var startRow = selectionStart[0]\r\n    var startCol = selectionStart[1]\r\n    var endRow = endLocation[0]\r\n    var endCol = endLocation[1]\r\n    while(startRow!=endRow || startCol!=endCol){\r\n        refBoard[startRow][startCol].style.background = \"orange\"\r\n        startRow += directionRow;\r\n        startCol += directionCol;\r\n    }\r\n    refBoard[startRow][startCol].style.background = \"orange\"\r\n}\r\n\r\nfunction highlightSolution(selectionStart, directionRow, directionCol, refBoard, nameRefs, idx){\r\n    var color = getColor()\r\n    var startRow = selectionStart[0]\r\n    var startCol = selectionStart[1]\r\n    while(startRow!=currentLocation[0] || startCol!=currentLocation[1]){\r\n        refBoard[startRow][startCol].style.color = color;\r\n        refBoard[startRow][startCol].style.fontWeight = \"bold\";\r\n        startRow += directionRow;\r\n        startCol += directionCol;\r\n    }\r\n    refBoard[startRow][startCol].style.color = color\r\n    refBoard[startRow][startCol].style.fontWeight = \"bold\";\r\n}\r\n\r\n// generate a loop of colors\r\nvar colors = [\"red\", \"blue\", \"orange\"]\r\nvar seed = Math.floor(Math.random() * colors.length)\r\nfunction getColor(){\r\n    var color = colors[seed%(colors.length)]\r\n    seed++;\r\n    return color\r\n}\r\n\r\n// guessing\r\nvar solutionBank = []\r\nvar guess = []\r\nvar currentLocation = []\r\nvar selectionStart = []\r\nvar selectionBegun = false;\r\nvar guessedList = []\r\n\r\n// board variables\r\nvar placedPeople = []\r\nconst defVal = '0'\r\nvar rows = 20\r\nvar cols = 20\r\nvar alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\r\nvar allDirections = [\r\n  [1,1],    //se\r\n  [1,0],    //s\r\n  [1,-1],   //sw\r\n  [0,-1],   //w\r\n  [-1,-1],  //nw\r\n  [-1,0],   //n\r\n  [-1,1],   //ne\r\n  [0,1],    //e\r\n]\r\n\r\nexport default WordSearchPage;","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/board.js",["189","190"],[],"import Square from \"./square\";\r\nimport styles from \"@/styles/crossword.module.css\";\r\nimport { useState, useEffect, useRef } from \"react\";\r\nimport ClueList from \"./clue_list\";\r\nimport { Modal } from \"@mui/material\";\r\nimport { useUser } from \"@/contexts/UserContext\";\r\nimport axios from 'axios'\r\n\r\nlet START_SQUARES = [];\r\n\r\nfunction Board() {\r\n  let BOARD = [];\r\n  let finished = false;\r\n  let ADDED_WORDS = [];\r\n  let NOT_ADDED = [];\r\n  let VERTICAL_WORDS = [];\r\n  let HORIZONTAL_WORDS = [];\r\n  let justAscendencyNums = [];\r\n  let DIMENSIONS = 32;\r\n  const { userFSData } = useUser();\r\n  let ANCESTORS = [];\r\n  let ascendencyNums = [];\r\n  \r\n  //Creates an array of all names that could be added to the crossword\r\n  for (const [key, value] of userFSData) {\r\n    let currentAncestorName = value.name.compressedName;\r\n    ANCESTORS.push({\r\n      CLUE: currentAncestorName,\r\n      ANSWER: currentAncestorName,\r\n      ASCENDENCY_NUM: key,\r\n    });\r\n  }\r\n  let SORTED_CLUE_LIST = sortKeyWords(ANCESTORS);\r\n  let REMAINING_WORDS = SORTED_CLUE_LIST;\r\n  const [clues, setClues] = useState([]);\r\n  const [board, setBoard] = useState([]);\r\n  const [vertClues, setVertClues] = useState([]);\r\n  const [horClues, setHorClues] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [puzzleIsCorrect, setPuzzleIsCorrect] = useState(false);\r\n  const inputLocation = useRef(new Array());\r\n\r\n  //Tells the page if it should be loading to make sure the clues are all set up before it is shown to the user\r\n  useEffect(() => {\r\n    if (clues.length > 0) {\r\n      setLoading(false);\r\n    }\r\n  }, [clues]);\r\n\r\n  useEffect(() => {\r\n    setBoard(\r\n      setUpBoard(\r\n        BOARD,\r\n        SORTED_CLUE_LIST,\r\n        START_SQUARES,\r\n        ADDED_WORDS,\r\n        REMAINING_WORDS,\r\n        NOT_ADDED\r\n      )\r\n    );\r\n  }, []);\r\n\r\n  // Handles what happens when the user solves the crossword\r\n  useEffect(() => {\r\n    setPuzzleIsCorrect(puzzleIsCorrect);\r\n  }, [puzzleIsCorrect]);\r\n\r\n  // Gets the clue data for each word that is put into the crossword and sets it to the clues variable\r\n  async function fetchData(userFSData, ascendancyNums) {\r\n    //TO TEST LOCALLY, COMMENT OUT THE LOWER URL AND UNCOMMENT THE TOP ONE. THEN WHEN YOU PUSH TO MAIN, MAKE SURE THE TOP URL IS COMMENTED AND THE BOTTOM IS NOT\r\n    const url = \"http://localhost:3000/api/questiongenerator\";\r\n    //const url = \"https://games.byufamilytech.org/api/questiongenerator\";\r\n  \r\n    try {\r\n      const res = await axios.post(url, {userFSData, ascendancyNums});\r\n      setClues(res.data);\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n  \r\n  useEffect(() => {\r\n    if (userFSData) {\r\n      console.log(\"data in if statement \" + Array.from(userFSData.values()).length);\r\n      const fsDataObj = Object.fromEntries(userFSData);\r\n      fetchData(fsDataObj, justAscendencyNums);\r\n    }\r\n  }, [])\r\n\r\n  // Handles what happens when a letter is changed on the board\r\n  function handleSquareInput(letter, row, col, inputLocation) {\r\n    let newBoard = board;\r\n    newBoard[row].CURRENT_ROW[col].CHARACTER = letter;\r\n    setBoard(newBoard);\r\n    setPuzzleIsCorrect(checkIfFinished());\r\n    if (inputLocation.current[row * DIMENSIONS + col].value == \"\") {\r\n      if (inputLocation.current[row * DIMENSIONS + col - 1].value != \"\") {\r\n        inputLocation.current[row * DIMENSIONS + col - 1].focus();\r\n      } else {\r\n        inputLocation.current[row * DIMENSIONS + col - DIMENSIONS].focus();\r\n      }\r\n    } else if (inputLocation.current[row * DIMENSIONS + col - 1].value != \"\") {\r\n      if (inputLocation.current[row * DIMENSIONS + col + 1].value != \"\") {\r\n        inputLocation.current[row * DIMENSIONS + col + 2].focus();\r\n      } else {\r\n        inputLocation.current[row * DIMENSIONS + col + 1].focus();\r\n      }\r\n    } else if (\r\n      inputLocation.current[row * DIMENSIONS + col - DIMENSIONS].value != \"\"\r\n    ) {\r\n      if (\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS].value != \"\"\r\n      ) {\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS * 2].focus();\r\n      } else {\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS].focus();\r\n      }\r\n    } else {\r\n      if (\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS].value != \"\"\r\n      ) {\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS * 2].focus();\r\n      } else if (\r\n        inputLocation.current[row * DIMENSIONS + col + 1].value != \"\"\r\n      ) {\r\n        inputLocation.current[row * DIMENSIONS + col + 2].focus();\r\n      } else {\r\n        inputLocation.current[row * DIMENSIONS + col + DIMENSIONS].focus();\r\n        inputLocation.current[row * DIMENSIONS + col + 1].focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  // Implements navigating the board with arrow keys and backspace on empty square\r\n  function handleKeyDown(event, row, col, inputLocation) {\r\n    if (event.keyCode === 37) {\r\n      let movedLocation = inputLocation.current[row * DIMENSIONS + col - 1].focus();\r\n      if (movedLocation != null) {\r\n        movedLocation.focus();\r\n        movedLocation.setSelectionRange(1,1);\r\n      }\r\n    } else if (event.keyCode === 38) {\r\n      let movedLocation = inputLocation.current[row * DIMENSIONS + col - DIMENSIONS];\r\n      if (movedLocation != null) {\r\n        movedLocation.focus();\r\n        movedLocation.setSelectionRange(1,1);\r\n      }\r\n    } else if (event.keyCode === 39) {\r\n      inputLocation.current[row * DIMENSIONS + col + 1].focus();\r\n    } else if (event.keyCode === 40) {\r\n      inputLocation.current[row * DIMENSIONS + col + DIMENSIONS].focus();\r\n    }\r\n  }\r\n\r\n  // Inserts all of the other words into the board except the first word\r\n  function insertAllWords(\r\n    board,\r\n    remainingWords,\r\n    addedWords,\r\n    START_SQUARES,\r\n    NOT_ADDED\r\n  ) {\r\n    let finished = false;\r\n    let attemptedInsertions = 0;\r\n    while (!finished) {\r\n      for (let i = 0; i < remainingWords.length; i++) {\r\n        attemptedInsertions++;\r\n        let wordInserted = checkAndInsertWord(\r\n          remainingWords[i].ANSWER,\r\n          board,\r\n          remainingWords,\r\n          addedWords,\r\n          START_SQUARES,\r\n          remainingWords[i].ASCENDENCY_NUM\r\n        );\r\n        if (wordInserted == true) {\r\n          break;\r\n        }\r\n      }\r\n      if (remainingWords.length < 1 || attemptedInsertions > 100) {\r\n        finished = true;\r\n      }\r\n      if (finished) {\r\n        if (remainingWords.length > 0) {\r\n          for (let i = 0; i < remainingWords.length; i++) {\r\n            NOT_ADDED.push(remainingWords[i].ANSWER);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    for (let i = 0; i < START_SQUARES.length; i++) {}\r\n  }\r\n  // Locates all of the possible places a word could go on the board and returns an array of those locations\r\n  function checkForCollisions(wordToAdd, currentBoard) {\r\n    let collisions = [];\r\n    for (let i = 0; i < DIMENSIONS; i++) {\r\n      for (let j = 0; j < DIMENSIONS; j++) {\r\n        if (wordToAdd.includes(currentBoard[i].CURRENT_ROW[j].KEY_CHARACTER)) {\r\n          collisions.push({\r\n            row: i,\r\n            col: j,\r\n            character: currentBoard[i].CURRENT_ROW[j].KEY_CHARACTER,\r\n          });\r\n        }\r\n      }\r\n    }\r\n    return collisions;\r\n  }\r\n\r\n  // Checks that a word can be inserted in a certain spot on the board and if it is possible to insert it, it inserts it\r\n  function checkAndInsertWord(\r\n    wordToAdd,\r\n    board,\r\n    remainingWords,\r\n    addedWords,\r\n    START_SQUARES,\r\n    aNum\r\n  ) {\r\n    let wordInserted = false;\r\n    let foundCollisions = checkForCollisions(wordToAdd, board);\r\n    for (let i = 0; i < foundCollisions.length; i++) {\r\n      let insertCheck = checkIfWordCanBeInserted(\r\n        wordToAdd,\r\n        foundCollisions[i],\r\n        board\r\n      );\r\n      if (insertCheck.INSERT == true) {\r\n        board = insertWord(\r\n          wordToAdd,\r\n          board,\r\n          foundCollisions[i],\r\n          insertCheck.DIRECTION,\r\n          START_SQUARES,\r\n          aNum\r\n        );\r\n        addedWords.push(wordToAdd);\r\n        let wordIndex = remainingWords.findIndex((object) => {\r\n          return object.ANSWER === wordToAdd;\r\n        });\r\n        remainingWords.splice(wordIndex, 1);\r\n\r\n        ascendencyNums.push({ ASCENDENCY_NUMBER: aNum, NAME: wordToAdd });\r\n        wordInserted = true;\r\n        break;\r\n      }\r\n    }\r\n    return wordInserted;\r\n  }\r\n  // Given a location that the word could potentially be inserted, it checks if it will collide with other words and accepts or rejects based on the current board state\r\n  function checkIfWordCanBeInserted(wordToAdd, collision, currentBoard) {\r\n    let canInsert = false;\r\n    let direction = \"horizontal\";\r\n    let charIndex = wordToAdd.indexOf(collision.character);\r\n    let splitWord = wordToAdd.split(collision.character);\r\n    let firstPart = \"\";\r\n    let secondPart = \"\";\r\n    if (splitWord.length == 2) {\r\n      firstPart = splitWord[0].split(\"\").reverse();\r\n      secondPart = splitWord[1].split(\"\");\r\n    } else if (splitWord.length > 2) {\r\n      firstPart = splitWord[0].split(\"\").reverse();\r\n      secondPart = splitWord[1];\r\n      for (let i = 2; i < splitWord.length; i++) {\r\n        secondPart += collision.character;\r\n        secondPart += splitWord[i];\r\n      }\r\n    } else {\r\n      if (charIndex == 0) {\r\n        secondPart = splitWord[0].split(\"\");\r\n      } else if ((charIndex = wordToAdd.length - 1)) {\r\n        firstPart = splitWord[0].split(\"\");\r\n      }\r\n    }\r\n    //Check to see if it can be inserted horizontally\r\n    if (\r\n      currentBoard[collision.row].CURRENT_ROW[collision.col + 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row].CURRENT_ROW[collision.col - 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row + 1].CURRENT_ROW[collision.col + 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row - 1].CURRENT_ROW[collision.col + 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row + 1].CURRENT_ROW[collision.col - 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row - 1].CURRENT_ROW[collision.col - 1]\r\n        .KEY_CHARACTER === \"*\"\r\n    ) {\r\n      for (let i = 1; i <= firstPart.length; i++) {\r\n        if (\r\n          (currentBoard[collision.row].CURRENT_ROW[collision.col - i]\r\n            .KEY_CHARACTER === \"*\" ||\r\n            currentBoard[collision.row].CURRENT_ROW[collision.col - i]\r\n              .KEY_CHARACTER === firstPart[i - 1]) &&\r\n          currentBoard[collision.row].CURRENT_ROW[collision.col - i]\r\n            .AVAILABLE == true &&\r\n          currentBoard[collision.row + 1].CURRENT_ROW[collision.col - i]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row - 1].CURRENT_ROW[collision.col - i]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row].CURRENT_ROW[collision.col - i - 1]\r\n            .AVAILABLE == true\r\n        ) {\r\n          canInsert = true;\r\n        } else {\r\n          canInsert = false;\r\n          return { INSERT: canInsert, DIRECTION: direction };\r\n        }\r\n      }\r\n      for (let i = 1; i <= secondPart.length; i++) {\r\n        if (\r\n          (currentBoard[collision.row].CURRENT_ROW[collision.col + i]\r\n            .KEY_CHARACTER === \"*\" ||\r\n            currentBoard[collision.row].CURRENT_ROW[collision.col + i]\r\n              .KEY_CHARACTER === secondPart[i - 1]) &&\r\n          currentBoard[collision.row].CURRENT_ROW[collision.col + i]\r\n            .AVAILABLE == true &&\r\n          currentBoard[collision.row + 1].CURRENT_ROW[collision.col + i]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row - 1].CURRENT_ROW[collision.col + i]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row].CURRENT_ROW[collision.col + i + 1]\r\n            .AVAILABLE == true\r\n        ) {\r\n          canInsert = true;\r\n        } else {\r\n          canInsert = false;\r\n          return { INSERT: canInsert, DIRECTION: direction };\r\n        }\r\n      }\r\n    }\r\n    if (\r\n      currentBoard[collision.row + 1].CURRENT_ROW[collision.col]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row - 1].CURRENT_ROW[collision.col]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row + 1].CURRENT_ROW[collision.col + 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row - 1].CURRENT_ROW[collision.col + 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row + 1].CURRENT_ROW[collision.col - 1]\r\n        .KEY_CHARACTER === \"*\" &&\r\n      currentBoard[collision.row - 1].CURRENT_ROW[collision.col - 1]\r\n        .KEY_CHARACTER === \"*\"\r\n    ) {\r\n      direction = \"vertical\";\r\n      for (let i = 1; i <= firstPart.length; i++) {\r\n        if (\r\n          (currentBoard[collision.row - i].CURRENT_ROW[collision.col]\r\n            .KEY_CHARACTER === \"*\" ||\r\n            currentBoard[collision.row - i].CURRENT_ROW[collision.col]\r\n              .KEY_CHARACTER === firstPart[i - 1]) &&\r\n          currentBoard[collision.row - i].CURRENT_ROW[collision.col]\r\n            .AVAILABLE == true &&\r\n          currentBoard[collision.row - i].CURRENT_ROW[collision.col + 1]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row - i].CURRENT_ROW[collision.col - 1]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row - i - 1].CURRENT_ROW[collision.col]\r\n            .AVAILABLE == true\r\n        ) {\r\n          canInsert = true;\r\n        } else {\r\n          canInsert = false;\r\n          return { INSERT: canInsert, DIRECTION: direction };\r\n        }\r\n      }\r\n      for (let i = 1; i <= secondPart.length; i++) {\r\n        if (\r\n          (currentBoard[collision.row + i].CURRENT_ROW[collision.col]\r\n            .KEY_CHARACTER === \"*\" ||\r\n            currentBoard[collision.row + i].CURRENT_ROW[collision.col]\r\n              .KEY_CHARACTER === secondPart[i - 1]) &&\r\n          currentBoard[collision.row + i].CURRENT_ROW[collision.col]\r\n            .AVAILABLE == true &&\r\n          currentBoard[collision.row + i].CURRENT_ROW[collision.col + 1]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row + i].CURRENT_ROW[collision.col - 1]\r\n            .KEY_CHARACTER == \"*\" &&\r\n          currentBoard[collision.row + i + 1].CURRENT_ROW[collision.col]\r\n            .AVAILABLE == true\r\n        ) {\r\n          canInsert = true;\r\n        } else {\r\n          canInsert = false;\r\n          return { INSERT: canInsert, DIRECTION: direction };\r\n        }\r\n      }\r\n    }\r\n    return { INSERT: canInsert, DIRECTION: direction };\r\n  }\r\n  // Inserts an individual word. It splits the word apart based on where it is going to go on the board, and updates the key characters of the new squares to the word's characters. It also updates the availability of the squares surrounding the newly placed word\r\n  function insertWord(\r\n    wordToAdd,\r\n    currentBoard,\r\n    collision,\r\n    direction,\r\n    START_SQUARES,\r\n    aNum\r\n  ) {\r\n    let charIndex = wordToAdd.indexOf(collision.character);\r\n    let splitWord = wordToAdd.split(collision.character);\r\n    let firstPart = \"\";\r\n    let secondPart = \"\";\r\n    if (splitWord.length == 2) {\r\n      firstPart = splitWord[0].split(\"\").reverse();\r\n      secondPart = splitWord[1].split(\"\");\r\n    } else if (splitWord.length > 2) {\r\n      firstPart = splitWord[0].split(\"\").reverse();\r\n      secondPart = splitWord[1];\r\n      for (let i = 2; i < splitWord.length; i++) {\r\n        secondPart += collision.character;\r\n        secondPart += splitWord[i];\r\n      }\r\n    } else {\r\n      if (charIndex == 0) {\r\n        secondPart = splitWord[0].split(\"\");\r\n      } else if ((charIndex = wordToAdd.length - 1)) {\r\n        firstPart = splitWord[0].split(\"\");\r\n      }\r\n    }\r\n    if (direction == \"horizontal\") {\r\n      let firstRow = 0;\r\n      let firstCol = 0;\r\n      if (firstPart.length == 0) {\r\n        firstRow = collision.row;\r\n        firstCol = collision.col;\r\n        START_SQUARES.push({ ROW: firstRow, COL: firstCol });\r\n      }\r\n      for (let i = 1; i <= firstPart.length; i++) {\r\n        currentBoard[collision.row].CURRENT_ROW[\r\n          collision.col - i\r\n        ].KEY_CHARACTER = firstPart[i - 1];\r\n        currentBoard[collision.row].CURRENT_ROW[\r\n          collision.col - i\r\n        ].AVAILABLE = false;\r\n        if (i == firstPart.length) {\r\n          firstRow = collision.row;\r\n          firstCol = collision.col - i;\r\n          START_SQUARES.push({ ROW: firstRow, COL: firstCol });\r\n        }\r\n      }\r\n      currentBoard[collision.row].CURRENT_ROW[\r\n        collision.col - firstPart.length - 1\r\n      ].AVAILABLE = false;\r\n      for (let i = 0; i <= secondPart.length; i++) {\r\n        currentBoard[collision.row].CURRENT_ROW[\r\n          collision.col + i\r\n        ].KEY_CHARACTER = secondPart[i - 1];\r\n        currentBoard[collision.row].CURRENT_ROW[\r\n          collision.col + i\r\n        ].AVAILABLE = false;\r\n      }\r\n      currentBoard[collision.row].CURRENT_ROW[\r\n        collision.col + secondPart.length + 1\r\n      ].AVAILABLE = false;\r\n      HORIZONTAL_WORDS.push({\r\n        WORD: wordToAdd,\r\n        CLUE_NUMBER:\r\n          START_SQUARES.indexOf(\r\n            START_SQUARES.filter(\r\n              (e) =>\r\n                e.ROW == collision.row &&\r\n                e.COL == collision.col - firstPart.length\r\n            )[0]\r\n          ) + 1,\r\n      });\r\n    }\r\n    if (direction == \"vertical\") {\r\n      let firstRow = 0;\r\n      let firstCol = 0;\r\n      if (firstPart.length == 0) {\r\n        firstRow = collision.row;\r\n        firstCol = collision.col;\r\n        START_SQUARES.push({ ROW: firstRow, COL: firstCol });\r\n      }\r\n      for (let i = 1; i <= firstPart.length; i++) {\r\n        currentBoard[collision.row - i].CURRENT_ROW[\r\n          collision.col\r\n        ].KEY_CHARACTER = firstPart[i - 1];\r\n        currentBoard[collision.row - i].CURRENT_ROW[\r\n          collision.col\r\n        ].AVAILABLE = false;\r\n        if (i == firstPart.length) {\r\n          firstRow = collision.row - i;\r\n          firstCol = collision.col;\r\n          START_SQUARES.push({ ROW: firstRow, COL: firstCol });\r\n        }\r\n      }\r\n      currentBoard[collision.row - firstPart.length - 1].CURRENT_ROW[\r\n        collision.col\r\n      ].AVAILABLE = false;\r\n      for (let i = 0; i <= secondPart.length; i++) {\r\n        currentBoard[collision.row + i].CURRENT_ROW[\r\n          collision.col\r\n        ].KEY_CHARACTER = secondPart[i - 1];\r\n        currentBoard[collision.row + i].CURRENT_ROW[\r\n          collision.col\r\n        ].AVAILABLE = false;\r\n      }\r\n      currentBoard[collision.row + secondPart.length + 1].CURRENT_ROW[\r\n        collision.col\r\n      ].AVAILABLE = false;\r\n      VERTICAL_WORDS.push({\r\n        WORD: wordToAdd,\r\n        CLUE_NUMBER:\r\n          START_SQUARES.indexOf(\r\n            START_SQUARES.filter(\r\n              (e) =>\r\n                e.ROW == collision.row - firstPart.length &&\r\n                e.COL == collision.col\r\n            )[0]\r\n          ) + 1,\r\n      });\r\n      setVertClues(VERTICAL_WORDS)\r\n    }\r\n    currentBoard[collision.row].CURRENT_ROW[collision.col].KEY_CHARACTER =\r\n      collision.character;\r\n    return currentBoard;\r\n  }\r\n  // Sorts the key words from longest word to shortest word\r\n  function sortKeyWords(ANCESTORS) {\r\n    let keyWordList = getAnswersFromClues(ANCESTORS);\r\n    keyWordList.sort(function (a, b) {\r\n      return b.ANSWER.length - a.ANSWER.length;\r\n    });\r\n    return keyWordList;\r\n  }\r\n\r\n  // Allows us to get all words put into the puzzle\r\n  function getAnswersFromClues(CLUE_LIST) {\r\n    let ANSWERS = [];\r\n    for (let i = 0; i < CLUE_LIST.length; i++) {\r\n      ANSWERS.push({\r\n        ANSWER: CLUE_LIST[i].ANSWER,\r\n        ASCENDENCY_NUM: CLUE_LIST[i].ASCENDENCY_NUM,\r\n      });\r\n    }\r\n    return ANSWERS;\r\n  }\r\n  // Puts the remaining words in a random order to generate a new crossword puzzle every time\r\n  function shuffle(array) {\r\n    let currentIndex = array.length,\r\n      randomIndex;\r\n    while (currentIndex != 0) {\r\n      randomIndex = Math.floor(Math.random() * currentIndex);\r\n      currentIndex--;\r\n      [array[currentIndex], array[randomIndex]] = [\r\n        array[randomIndex],\r\n        array[currentIndex],\r\n      ];\r\n    }\r\n    return array;\r\n  }\r\n  // Sets up the board before the user can see it\r\n  function setUpBoard(\r\n    BOARD,\r\n    SORTED_CLUE_LIST,\r\n    START_SQUARES,\r\n    ADDED_WORDS,\r\n    REMAINING_WORDS,\r\n    NOT_ADDED\r\n  ) {\r\n    for (let currentRow = 0; currentRow < DIMENSIONS; currentRow++) {\r\n      let CURRENT_ROW = [];\r\n      for (let currentCol = 0; currentCol < DIMENSIONS; currentCol++) {\r\n        CURRENT_ROW.push({\r\n          ROW: currentRow,\r\n          COL: currentCol,\r\n          KEY_CHARACTER:\r\n            currentRow == 0 ||\r\n            currentRow == DIMENSIONS - 1 ||\r\n            currentCol == 0 ||\r\n            currentCol == DIMENSIONS - 1\r\n              ? \"&\"\r\n              : \"*\",\r\n          CHARACTER:\r\n            currentRow == 0 ||\r\n            currentRow == DIMENSIONS - 1 ||\r\n            currentCol == 0 ||\r\n            currentCol == DIMENSIONS - 1\r\n              ? \"&\"\r\n              : \"*\",\r\n          id: currentRow + \"x\" + currentCol,\r\n          AVAILABLE:\r\n            currentRow == 0 ||\r\n            currentRow == DIMENSIONS - 1 ||\r\n            currentCol == 0 ||\r\n            currentCol == DIMENSIONS - 1\r\n              ? false\r\n              : true,\r\n        });\r\n      }\r\n      BOARD.push({ CURRENT_ROW, id: currentRow });\r\n    }\r\n\r\n    const randomAncestor = SORTED_CLUE_LIST[Math.floor(Math.random() * SORTED_CLUE_LIST.length)]\r\n\r\n    BOARD = insertFirstWord(\r\n      9,\r\n      4,\r\n      //randomAncestor.ANSWER,\r\n      SORTED_CLUE_LIST[0].ANSWER,\r\n      BOARD,\r\n      START_SQUARES,\r\n      ADDED_WORDS,\r\n      REMAINING_WORDS,\r\n      SORTED_CLUE_LIST[0].ASCENDENCY_NUM\r\n    );\r\n    shuffle(REMAINING_WORDS);\r\n    insertAllWords(\r\n      BOARD,\r\n      REMAINING_WORDS,\r\n      ADDED_WORDS,\r\n      START_SQUARES,\r\n      NOT_ADDED\r\n    );\r\n\r\n    for (let i = 0; i < ascendencyNums.length; i++) {\r\n      justAscendencyNums[i] = ascendencyNums[i].ASCENDENCY_NUMBER;\r\n    }\r\n    \r\n    return BOARD;\r\n  }\r\n  // Inserts the first word at a set position in the board\r\n  function insertFirstWord(\r\n    rowIndex,\r\n    colIndex,\r\n    word,\r\n    currentBoard,\r\n    START_SQUARES,\r\n    ADDED_WORDS,\r\n    REMAINING_WORDS,\r\n    aNum\r\n  ) {\r\n    let canInsertWord = false;\r\n    let wordIndex = 0;\r\n    if (word.length < DIMENSIONS - 5) {\r\n      canInsertWord = true;\r\n    } else {\r\n      for (let i = 1; i < REMAINING_WORDS.length; i++) {\r\n        if (REMAINING_WORDS[i].ANSWER.length < DIMENSIONS - 6) {\r\n          canInsertWord = true;\r\n          word = REMAINING_WORDS[i].ANSWER;\r\n          wordIndex = i;\r\n        }\r\n      }\r\n    }\r\n    if (canInsertWord) {\r\n      let splitWord = word.split(\"\");\r\n      for (let i = 0; i < splitWord.length; i++) {\r\n        currentBoard[rowIndex].CURRENT_ROW[colIndex + i].KEY_CHARACTER =\r\n          splitWord[i];\r\n        currentBoard[rowIndex].CURRENT_ROW[colIndex + i].AVAILABLE = false;\r\n      }\r\n      START_SQUARES.push({ ROW: rowIndex, COL: colIndex });\r\n      ADDED_WORDS.push(word);\r\n      HORIZONTAL_WORDS.push({\r\n        WORD: word,\r\n        CLUE_NUMBER:\r\n          START_SQUARES.indexOf(\r\n            START_SQUARES.filter(\r\n              (e) => e.ROW == rowIndex && e.COL == colIndex\r\n            )[0]\r\n          ) + 1,\r\n      });\r\n      setHorClues(HORIZONTAL_WORDS)\r\n      REMAINING_WORDS.splice(wordIndex, 1);\r\n      ascendencyNums.push({ ASCENDENCY_NUMBER: aNum, NAME: word });\r\n    }\r\n    return currentBoard;\r\n  }\r\n\r\n  // Loops through the 2D array to check if each key character matches each entered character\r\n  function checkIfFinished() {\r\n    for (let i = 0; i < board.length; i++) {\r\n      for (let j = 0; j < board[i].CURRENT_ROW.length; j++) {\r\n        if (\r\n          board[i].CURRENT_ROW[j].CHARACTER.toLowerCase() !=\r\n          board[i].CURRENT_ROW[j].KEY_CHARACTER.toLowerCase()\r\n        ) {\r\n          finished = false;\r\n          return finished;\r\n        }\r\n      }\r\n    }\r\n    finished = true;\r\n    return finished;\r\n  }\r\n\r\n  let clueNumber = -1;\r\n  return !loading ?(\r\n    <>\r\n      <div>\r\n        {board.map((rows) => {\r\n          return (\r\n            <div className={styles.div} key={rows.id}>\r\n              {rows.CURRENT_ROW.map((rowItems) => {\r\n                {\r\n                  clueNumber =\r\n                    START_SQUARES.indexOf(\r\n                      START_SQUARES.filter(\r\n                        (e) => e.ROW == rowItems.ROW && e.COL == rowItems.COL\r\n                      )[0]\r\n                    ) + 1;\r\n                }\r\n                return (\r\n                  <Square\r\n                    row={rowItems.ROW}\r\n                    col={rowItems.COL}\r\n                    character={rowItems.CHARACTER}\r\n                    key_character={rowItems.KEY_CHARACTER}\r\n                    key={rowItems.id}\r\n                    clueNumber={clueNumber}\r\n                    handleSquareInput={handleSquareInput}\r\n                    handleKeyDown={handleKeyDown}\r\n                    dimensions={DIMENSIONS}\r\n                    inputLocation={inputLocation}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n        {(START_SQUARES = [])}\r\n      </div>\r\n      <ClueList\r\n        verticalClues={vertClues}\r\n        horizontalClues={horClues}\r\n        result={clues}\r\n      />\r\n      <Modal open={puzzleIsCorrect} onClose={() => setPuzzleIsCorrect(false)}>\r\n        <div className={styles.modal_container}>\r\n          <button\r\n            className={styles.close_btn}\r\n            onClick={() => setPuzzleIsCorrect(false)}\r\n          >\r\n            X\r\n          </button>\r\n          <h3>Congrats on solving the Crossword! </h3>\r\n        </div>\r\n      </Modal>\r\n    </>\r\n  ): (<div>Loading...</div>);\r\n}\r\nexport default Board;\r\n","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/clue.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/clue_list.js",["191"],[],"import Clue from \"./clue\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nfunction ClueList(props) {\r\n  let { verticalClues, horizontalClues, result } = props;\r\n  const [clueList, setClueList] = useState({VERTICAL: verticalClues, HORIZONTAL:horizontalClues});\r\n  useEffect(() => {\r\n    setClueList(makeClueList());\r\n  }, []);\r\n  function makeClueList() {\r\n    for (let i = 0; i < verticalClues.length; i++) {\r\n      verticalClues[i].CLUE = verticalClues[i].WORD;\r\n    }\r\n    for (let i = 0; i < horizontalClues.length; i++) {\r\n      horizontalClues[i].CLUE = horizontalClues[i].WORD;\r\n    }\r\n    let clues = {VERTICAL: verticalClues, HORIZONTAL: horizontalClues}\r\n    return clues;\r\n  }\r\n  clueList.VERTICAL.sort((a, b) => a.CLUE_NUMBER - b.CLUE_NUMBER);\r\n  clueList.HORIZONTAL.sort((a, b) => a.CLUE_NUMBER - b.CLUE_NUMBER); \r\n\r\n  for (let i = 0; i < clueList.VERTICAL.length; i++) {\r\n    let hint = result.find(item => item.answer === clueList.VERTICAL[i].WORD);\r\n    if (hint != null) {\r\n      clueList.VERTICAL[i].CLUE = hint.clue\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < clueList.HORIZONTAL.length; i++) {\r\n    let hint = result.find(item => item.answer === clueList.HORIZONTAL[i].WORD);\r\n    if (hint != null) {\r\n      clueList.HORIZONTAL[i].CLUE = hint.clue\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div>\r\n        <h1>Clues</h1>\r\n        <h2>Down</h2>\r\n        {clueList.VERTICAL.map((clues) => {\r\n          return (\r\n            <div key={clues.CLUE_NUMBER}>\r\n              <Clue number={clues.CLUE_NUMBER} word={clues.WORD} clue={clues.CLUE} />\r\n            </div>\r\n          );\r\n        })}\r\n        <h2>Across</h2>\r\n        {clueList.HORIZONTAL.map((clues) => {\r\n          return (\r\n            <div key={clues.CLUE_NUMBER}>\r\n              <Clue number={clues.CLUE_NUMBER} word={clues.WORD} clue={clues.CLUE} />\r\n            </div>\r\n          );\r\n        })}\r\n        <h3>Answers can be seen by right-clicking the clue</h3>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\nexport default ClueList;","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/crossword/square.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game.js",["192"],[],"import Link from 'next/link';\r\nimport Image from 'next/image';\r\nimport { useSwipeable } from 'react-swipeable';\r\n\r\nimport styles from '@/styles/game.module.css';\r\nimport GameCardPitch from './game_card_pitch.js';\r\nimport GameCardComingSoon from './game_card_coming_soon.js';\r\nimport { useState } from 'react';\r\n\r\n\r\n/** \r\n * Used to display a game with its name and image on the home page.\r\n * Also holds the links to the games and a card animation to show instructions.\r\n * If a game is in development, it will not have a link, it will display a \r\n * coming soon page instead of a game pitch, and the game image will be greyed out.\r\n*/\r\nexport default function Game(props) {\r\n\r\n  const { title, url, image, pitch, prodReady } = props;\r\n  const [cardFlip, setCardFlip] = useState(false);\r\n\r\n\r\n  const handleSwipe = () => {\r\n    setCardFlip(!cardFlip);\r\n  }\r\n\r\n  //For swiping functionality on mobile\r\n  const swipeHandler = useSwipeable({\r\n    onSwipedLeft: handleSwipe,\r\n    onSwipedRight: handleSwipe,\r\n  });\r\n\r\n\r\n\r\n  if (prodReady) {\r\n    return (\r\n      <div {...swipeHandler}>\r\n        { prodGame(title, url, image, pitch, cardFlip) }\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div {...swipeHandler}>\r\n      { devGame(title, image, cardFlip) }\r\n    </div>\r\n  )\r\n\r\n  \r\n}\r\n\r\nfunction prodGame(title, url, image, pitch, cardFlip) {\r\n\r\n  return (\r\n\r\n    <Link href={url}>\r\n\r\n      <div className={styles.column_container}>\r\n      <div className={cardFlip ? styles.game_container_hover : styles.game_container}>\r\n\r\n        <div className={styles.flip_card_inner}>\r\n          <div className={styles.flip_card_front}>\r\n          \r\n\r\n            <Image\r\n              src={image}\r\n              alt=\"Game Picture\"\r\n              height=\"300px\"\r\n              width=\"250px\"\r\n              className={styles.image}\r\n            />\r\n\r\n\r\n            <div className={styles.title_box}>\r\n              <h4 className={styles.title}>{title}</h4>\r\n            </div>\r\n          </div>\r\n\r\n\r\n          <div className={styles.flip_card_back}>\r\n            <GameCardPitch pitch={pitch} title={title}/>\r\n          </div>\r\n\r\n\r\n        </div>\r\n      </div>\r\n      </div>\r\n\r\n    </Link>\r\n\r\n  )\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction devGame(title, image, cardFlip) {\r\n\r\n  return (\r\n    <div className={styles.column_container}>\r\n    <div className={cardFlip ? styles.in_dev_game_container_hover : styles.in_dev_game_container}>\r\n\r\n      <div className={styles.flip_card_inner}>\r\n        <div className={styles.flip_card_front}>\r\n        \r\n\r\n          <Image\r\n            src={image}\r\n            alt=\"Game Picture\"\r\n            height=\"300px\"\r\n            width=\"250px\"\r\n            priority=\"true\"\r\n            className={styles.in_dev_image}\r\n          />\r\n\r\n          {/* Display Coming Soon sign */}\r\n          <h1 className={styles.in_dev_sign}>\r\n            Coming Soon\r\n          </h1>\r\n\r\n\r\n          <div className={styles.title_box}>\r\n            <h4 className={styles.title}>{title}</h4>\r\n          </div>\r\n\r\n        </div>\r\n\r\n\r\n        <div className={styles.flip_card_back}>\r\n          <GameCardComingSoon/>\r\n        </div>\r\n\r\n\r\n      </div>\r\n    </div>\r\n    </div>\r\n  )\r\n\r\n\r\n}\r\n","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game_card_coming_soon.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/home/game_card_pitch.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/login_button.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/grid.js",["193"],[],"import styles from \"@/styles/matching.module.css\";\r\nimport { useState, useEffect } from \"react\";\r\nimport { PersonImage } from \"../person_image\";\r\nimport { useUser } from \"@/contexts/UserContext\";\r\n\r\nfunction Grid() {\r\n\r\n  const { userFSData } = useUser();\r\n  let board = [];\r\n\r\n  const [boardData, setBoardData] = useState([]);\r\n  const [flippedCards, setFlippedCards] = useState([]);\r\n  const [matchedCards, setMatchedCards] = useState([]);\r\n  const [moves, setMoves] = useState(0);\r\n  const [gameOver, setGameOver] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (matchedCards.length === 18) {\r\n      setGameOver(true);\r\n    }\r\n  }, [matchedCards]);\r\n\r\n  useEffect(() => {\r\n    initialize();\r\n  }, []);\r\n\r\n  const getAncestors = () => {\r\n    console.log(userFSData);\r\n    while (board.length < 9) {\r\n      const keysArray = Array.from(userFSData.keys());\r\n      const randomKey = keysArray[Math.floor(Math.random() * keysArray.length)];\r\n      const newObject = {\r\n        firstName: userFSData.get(randomKey).name.first,\r\n        gender: userFSData.get(randomKey).gender,\r\n        pid: userFSData.get(randomKey).pid\r\n      };\r\n      \r\n      const isDuplicate = board.some(obj =>\r\n        obj.firstName === newObject.firstName &&\r\n        obj.gender === newObject.gender &&\r\n        obj.pid === newObject.pid\r\n      );\r\n  \r\n      if (!isDuplicate) {\r\n        board.push(newObject);\r\n      }\r\n    }\r\n  \r\n    console.log(board);\r\n  }\r\n\r\n  const shuffle = () => {\r\n    const shuffledCards = [...board, ...board]\r\n      .sort(() => Math.random() - 0.5)\r\n      .map((v) => v);\r\n\r\n    setBoardData(shuffledCards);\r\n  };\r\n\r\n  const initialize = () => {\r\n    getAncestors();\r\n    shuffle();\r\n    setGameOver(false);\r\n    setFlippedCards([]);\r\n    setMatchedCards([]);\r\n    setMoves(0);\r\n  };\r\n\r\n  const updateActiveCards = (i) => {\r\n    if (!flippedCards.includes(i)) {\r\n      if (flippedCards.length === 1) {\r\n        const firstIdx = flippedCards[0];\r\n        const secondIdx = i;\r\n        if (boardData[firstIdx] === boardData[secondIdx]) {\r\n          setMatchedCards((prev) => [...prev, firstIdx, secondIdx]);\r\n        }\r\n\r\n        setFlippedCards([...flippedCards, i]);\r\n      } else if (flippedCards.length === 2) {\r\n        console.log(\"flipped is 1\");\r\n        setFlippedCards([i]);\r\n      } else {\r\n        setFlippedCards([...flippedCards, i]);\r\n      }\r\n\r\n      setMoves((v) => v + 1);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={styles.main}>\r\n      <div className={styles.menu}>\r\n        <p>{`Moves - ${moves}`}</p>\r\n      </div>\r\n\r\n      <div className={styles.board}>\r\n        {boardData.map((data, i) => {\r\n          const flipped = flippedCards.includes(i) ? true : false;\r\n          const matched = matchedCards.includes(i) ? true : false;\r\n          return (\r\n            <div\r\n              onClick={() => {\r\n                updateActiveCards(i);\r\n              }}\r\n              key={i}\r\n              className={`${styles.card} ${flipped || matched ? styles.active : \"\"} ${\r\n                matched ? styles.matched : \"\"\r\n              } ${gameOver ? styles.gameOver : \"\"}`}\r\n            >\r\n              {flipped ? (\r\n                <PersonImage\r\n                pid={data.pid}\r\n                imageHeight={100}\r\n                imageWidth={100}\r\n                gender={data.gender}\r\n              />\r\n              ) : (\r\n                \"\"\r\n              )}\r\n\r\n              {/* { <div>{data.firstName}</div> }\r\n              <PersonImage\r\n                pid={data.pid}\r\n                imageHeight={100}\r\n                imageWidth={100}\r\n                gender={data.gender}\r\n              /> */}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n      <div className={styles.menu}>\r\n        <p>{`GameOver - ${gameOver}`}</p>\r\n        <button onClick={() => initialize()}>Reset</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Grid;","/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/match_board.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/matching/roomSetup.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/menu/contact.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/menu/menu_dialog.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/person.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/person_image.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/victory_modal.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/components/word_scramble/scramble_solve.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/lib/theme.js",[],[],"/Users/haydenlowry/Documents/School/IS/IS 405/familytech-games/src/lib/utils.js",[],[],{"ruleId":"194","severity":1,"message":"195","line":10,"column":11,"nodeType":"196","endLine":10,"endColumn":42},{"ruleId":"197","severity":1,"message":"198","line":17,"column":6,"nodeType":"199","endLine":17,"endColumn":8,"suggestions":"200"},{"ruleId":"197","severity":1,"message":"201","line":15,"column":6,"nodeType":"199","endLine":15,"endColumn":20,"suggestions":"202"},{"ruleId":"197","severity":1,"message":"203","line":63,"column":45,"nodeType":"199","endLine":63,"endColumn":58,"suggestions":"204"},{"ruleId":"197","severity":1,"message":"205","line":61,"column":6,"nodeType":"199","endLine":61,"endColumn":8,"suggestions":"206"},{"ruleId":"197","severity":1,"message":"207","line":88,"column":6,"nodeType":"199","endLine":88,"endColumn":8,"suggestions":"208"},{"ruleId":"197","severity":1,"message":"209","line":9,"column":6,"nodeType":"199","endLine":9,"endColumn":8,"suggestions":"210"},{"ruleId":"211","severity":1,"message":"212","line":56,"column":5,"nodeType":"213","endLine":56,"endColumn":22},{"ruleId":"197","severity":1,"message":"214","line":25,"column":6,"nodeType":"199","endLine":25,"endColumn":8,"suggestions":"215"},"@next/next/no-title-in-document-head","Titles should be defined at the page-level using next/head. See: https://nextjs.org/docs/messages/no-title-in-document-head","JSXElement","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'userFSData'. Either include it or remove the dependency array.","ArrayExpression",["216"],"React Hook useEffect has a missing dependency: 'router'. Either include it or remove the dependency array.",["217"],"React Hook useEffect has a missing dependency: 'populateBoard'. Either include it or remove the dependency array.",["218"],"React Hook useEffect has missing dependencies: 'ADDED_WORDS', 'BOARD', 'NOT_ADDED', 'REMAINING_WORDS', 'SORTED_CLUE_LIST', and 'setUpBoard'. Either include them or remove the dependency array.",["219"],"React Hook useEffect has missing dependencies: 'justAscendencyNums' and 'userFSData'. Either include them or remove the dependency array.",["220"],"React Hook useEffect has a missing dependency: 'makeClueList'. Either include it or remove the dependency array.",["221"],"@next/next/link-passhref","passHref is missing. See: https://nextjs.org/docs/messages/link-passhref","JSXOpeningElement","React Hook useEffect has a missing dependency: 'initialize'. Either include it or remove the dependency array.",["222"],{"desc":"223","fix":"224"},{"desc":"225","fix":"226"},{"desc":"227","fix":"228"},{"desc":"229","fix":"230"},{"desc":"231","fix":"232"},{"desc":"233","fix":"234"},{"desc":"235","fix":"236"},"Update the dependencies array to be: [userFSData]",{"range":"237","text":"238"},"Update the dependencies array to be: [cookieExists, router]",{"range":"239","text":"240"},"Update the dependencies array to be: [peopleArray, populateBoard]",{"range":"241","text":"242"},"Update the dependencies array to be: [ADDED_WORDS, BOARD, NOT_ADDED, REMAINING_WORDS, SORTED_CLUE_LIST, setUpBoard]",{"range":"243","text":"244"},"Update the dependencies array to be: [justAscendencyNums, userFSData]",{"range":"245","text":"246"},"Update the dependencies array to be: [makeClueList]",{"range":"247","text":"248"},"Update the dependencies array to be: [initialize]",{"range":"249","text":"250"},[636,638],"[userFSData]",[422,436],"[cookieExists, router]",[2194,2207],"[peopleArray, populateBoard]",[1817,1819],"[ADDED_WORDS, BOARD, NOT_ADDED, REMAINING_WORDS, SORTED_CLUE_LIST, setUpBoard]",[2870,2872],"[justAscendencyNums, userFSData]",[323,325],"[makeClueList]",[702,704],"[initialize]"]